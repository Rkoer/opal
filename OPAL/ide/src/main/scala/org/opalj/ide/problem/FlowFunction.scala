/* BSD 2-Clause License - see OPAL/LICENSE for details. */
package org.opalj.ide.problem

import scala.language.implicitConversions

import scala.collection.immutable

import org.opalj.fpcf.SomeEOptionP

/**
 * Interface representing IDE flow functions
 */
trait FlowFunction[Fact <: IDEFact] {
    type FactsAndDependees = FlowFunction.FactsAndDependees[Fact]

    implicit def setOfFactsToFactsAndDependees(facts: collection.Set[? <: Fact]): FactsAndDependees = {
        (facts.toSet, immutable.Set.empty)
    }

    /**
     * Compute the facts that are generated by this flow function when seeing a fact and the dependees that can cause
     * new facts to be generated
     * @param sourceFact the incoming fact
     */
    def compute(sourceFact: Fact): FactsAndDependees
}

object FlowFunction {
    type FactsAndDependees[Fact] = (collection.Set[Fact], collection.Set[SomeEOptionP])
}

/**
 * Special flow function that always returns the input fact
 */
case class IdentityFlowFunction[Fact <: IDEFact]() extends FlowFunction[Fact] {
    override def compute(sourceFact: Fact): FactsAndDependees =
        immutable.Set(sourceFact)
}

/**
 * Special flow function that always returns an empty set
 */
case class EmptyFlowFunction[Fact <: IDEFact]() extends FlowFunction[Fact] {
    override def compute(sourceFact: Fact): FactsAndDependees =
        immutable.Set.empty[Fact]
}
